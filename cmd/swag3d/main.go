package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"path"

	"github.com/recolude/swagger-unity-codegen/unitygen"
	"github.com/recolude/swagger-unity-codegen/unitygen/convention"
	"github.com/recolude/swagger-unity-codegen/unitygen/definition"
	"github.com/recolude/swagger-unity-codegen/unitygen/security"
	"github.com/spf13/afero"
	"github.com/urfave/cli/v2"
)

func filterSpecForTags(spec unitygen.Spec, tags []string) unitygen.Spec {
	if tags == nil {
		return spec
	}
	filteredServices := make([]unitygen.Service, 0)
	for _, service := range spec.Services {

		for _, tag := range tags {
			if service.Name() == tag {
				filteredServices = append(filteredServices, service)
			}
		}
	}
	spec.Services = filteredServices
	return spec
}

// func filterSpecForUnusedDefinitions(spec unitygen.Spec) unitygen.Spec {
// 	filteredDefinitions := make([]definition.Definition, 0)
// 	spec.Definitions = filteredDefinitions
// 	return spec
// }

func fileCommentHeader(out io.Writer) {
	fmt.Fprintln(out, "// This code was generated by: ")
	fmt.Fprintln(out, "// https://github.com/recolude/swagger-unity-codegen")
	fmt.Fprintln(out, "// Issues and PRs welcome :)")
	fmt.Fprintln(out, "")
}

func fileImports(out io.Writer) {
	fmt.Fprintln(out, "using UnityEngine;")
	fmt.Fprintln(out, "using UnityEngine.Networking;")
	fmt.Fprintln(out, "using System.Collections;")
	fmt.Fprintln(out, "")
}

func writeDefinitions(out io.Writer, defs []definition.Definition) {
	for _, def := range defs {
		fmt.Fprintf(out, "%s\n\n", def.ToCSharp())
	}
}

func writeServices(out io.Writer, services []unitygen.Service, authDefinitions []security.Auth) {
	for _, def := range services {
		fmt.Fprintf(out, "%s\n\n", def.ToCSharp(authDefinitions, "Config"))
	}
}

func openNamespace(out io.Writer, namespace string) {
	if namespace == "" {
		return
	}
	fmt.Fprintf(out, "namespace %s {\n\n", convention.TitleCase(namespace))
}

func closeNamespace(out io.Writer, namespace string) {
	if namespace == "" {
		return
	}
	fmt.Fprint(out, "}")
}

// allOutAtOnce is for when you want the entirety of the swagger in a single file.
func allOutAtOnce(c *cli.Context, spec unitygen.Spec) error {

	fileCommentHeader(c.App.Writer)
	fileImports(c.App.Writer)

	namespace := c.String("namespace")

	openNamespace(c.App.Writer, namespace)

	// Define out all classes!
	fmt.Fprint(c.App.Writer, "#region Definitions\n\n")
	writeDefinitions(c.App.Writer, spec.Definitions)
	fmt.Fprintf(c.App.Writer, "%s\n\n", "#endregion")

	fmt.Fprintf(c.App.Writer, "%s\n\n", "#region Services")
	fmt.Fprintf(c.App.Writer, "%s\n\n", spec.ServiceConfig(c.String("config-name"), c.String("config-menu")))
	writeServices(c.App.Writer, spec.Services, spec.AuthDefinitions)
	fmt.Fprint(c.App.Writer, "#endregion\n\n")

	closeNamespace(c.App.Writer, namespace)

	return nil
}

func toDir(fs afero.Fs, c *cli.Context, location string, spec unitygen.Spec) error {
	namespace := c.String("namespace")

	err := fs.MkdirAll(location, os.ModePerm)
	if err != nil {
		return fmt.Errorf("Error creating folder: %w", err)
	}

	definitionsFile, err := fs.Create(path.Join(location, "Definitions.cs"))
	if err != nil {
		return fmt.Errorf("Error creating definitions file: %w", err)
	}
	fileCommentHeader(definitionsFile)
	fileImports(definitionsFile)
	openNamespace(definitionsFile, namespace)
	writeDefinitions(definitionsFile, spec.Definitions)
	closeNamespace(definitionsFile, namespace)

	servicesFile, err := fs.Create(path.Join(location, "Services.cs"))
	if err != nil {
		return fmt.Errorf("Error creating services file: %w", err)
	}
	fileCommentHeader(servicesFile)
	fileImports(servicesFile)
	openNamespace(servicesFile, namespace)
	writeServices(servicesFile, spec.Services, spec.AuthDefinitions)
	closeNamespace(servicesFile, namespace)

	configFile, err := fs.Create(path.Join(location, fmt.Sprintf("%s.cs", convention.TitleCase(c.String("config-name")))))
	if err != nil {
		return fmt.Errorf("Error creating config file: %w", err)
	}
	fileCommentHeader(configFile)
	fileImports(configFile)
	openNamespace(configFile, namespace)
	fmt.Fprintf(configFile, "%s\n\n", spec.ServiceConfig(c.String("config-name"), c.String("config-menu")))
	closeNamespace(configFile, namespace)

	return nil
}

func buildApp(fs afero.Fs, out io.Writer, errOut io.Writer) *cli.App {
	return &cli.App{
		Name:        "swag3d",
		Description: "Generate C# code specifically for Unity3D from a swagger file",
		Version:     "0.1.0",
		Usage:       "swagger and Unity3D meet",
		Writer:      out,
		ErrWriter:   errOut,
		Authors: []*cli.Author{
			{
				Name: "Elijah C Davis",
			},
		},
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:  "file, f",
				Usage: "where to load swagger from",
				Value: "swagger.json",
			},
		},
		Commands: []*cli.Command{
			{
				Name:    "generate",
				Aliases: []string{"g"},
				Usage:   "Generate c# code from a swagger file",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "namespace",
						Usage: "The namespace the code will be wrapped in",
					},
					&cli.StringFlag{
						Name:        "config-name",
						Usage:       "The name of the config class that will contain all server variables",
						Value:       "ServiceConfig",
						DefaultText: "ServiceConfig",
					},
					&cli.StringFlag{
						Name:        "config-menu",
						Usage:       "Name to be listed in the Assets/Create submenu, so that instances of the server config can be easily created and stored in the project as \".asset\"",
						Value:       "Server/Config",
						DefaultText: "Server/Config",
					},
					// &cli.BoolFlag{
					// 	Name:  "include-unused",
					// 	Usage: "Whether or not to include definitions that where never used in the different services",
					// 	Value: false,
					// },
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "Specify tags that a route must have to be included in the export. Specifying no tags means include all routes",
					},

					&cli.StringFlag{
						Name:        "out",
						Usage:       "The directory where you want the contents to be written to disc",
						DefaultText: "",
					},
				},
				Action: func(c *cli.Context) error {

					file, err := fs.Open(c.String("file"))
					if err != nil {
						return fmt.Errorf("Error opening swagger file: %w", err)
					}

					spec, err := unitygen.Parser{}.ParseJSON(file)
					if err != nil {
						return fmt.Errorf("Error reading from swagger file: %w", err)
					}
					spec = filterSpecForTags(spec, c.StringSlice("tags"))

					if c.IsSet("out") {
						return toDir(fs, c, c.String("out"), spec)
					}

					return allOutAtOnce(c, spec)
				},
			},
		},
	}
}

func main() {
	app := buildApp(afero.NewOsFs(), os.Stdout, os.Stderr)

	err := app.Run(os.Args)
	if err != nil {
		log.Fatal(err)
	}
}
